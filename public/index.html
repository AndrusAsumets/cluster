<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
		<script type="text/javascript" src="/js/bower_components/pathfinding/pathfinding-browser.min.js"></script>
		<style>
			.unselectable {
				user-select: none;
				-moz-user-select: none;
				-khtml-user-select: none;
				-webkit-user-select: none;
				-o-user-select: none;
			}
			
			html, body {
				margin: 0;
				padding: 0;
				width: 100vw;
				height: 100vh;
				background-color: black;
				overflow: hidden;
			}
			
			.controller {
				display: none;
				position: absolute;
				top: 0;
				width: calc(100vw / 7 - 2vw);
				color: black;
				top: 50%;
				transform: translateY(-50%);
				z-index: 2;
			}
			
			.controller.left {
				left: 1vw;
			}
		
			.controller.right {
				right: 1vw;
			}
			
			.elements {
				width: 100%;
				height: 100vh;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
			}
			
			.element {
				width: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
				height: calc(100vh / 6);
				margin: 0.5vh 2vw;
				box-sizing: border-box;
				cursor: pointer;
				color: white;
				font-size: 1em;
				font-family: 'Helvetica Neue', 'sans';
			}
			
			.rock {
				background-color: red;
			}
			
			.paper {
				background-color: green;
			}
			
			.scissors {
				background-color: blue;
			}
			
			canvas {
				left: 50%;
				top: calc(100% / 9);
				transform: translate(-50%, 0);
			}
			
			canvas:nth-child(1) {
				border-right: 1px solid black;
			}
		</style
	</head>

	<body>
		<div class="game"></div>
		<div class="controller left">
			<div class="elements">
				<div class="element rock unselectable">rock</div>
				<div class="element paper unselectable">paper</div>
				<div class="element scissors unselectable">scissors</div>
			</div>
		</div>
		<div class="controller right">
			<div class="elements">
				<div class="element rock unselectable">rock</div>
				<div class="element paper unselectable">paper</div>
				<div class="element scissors unselectable">scissors</div>
			</div>
		</div>
		
		<script>			
			document.addEventListener('touchstart', function(event) { createElement(event.touches[0]) })
			
			var PIXEL_RATIO = (function () {
			    var ctx = document.createElement('canvas').getContext('2d'),
			        dpr = window.devicePixelRatio || 1,
			        bsr = ctx.webkitBackingStorePixelRatio ||
			              ctx.mozBackingStorePixelRatio ||
			              ctx.msBackingStorePixelRatio ||
			              ctx.oBackingStorePixelRatio ||
			              ctx.backingStorePixelRatio || 1
			
			    return dpr / bsr
			})()
			
			var types = ['earth', 'water', 'fire', 'air']
			var matrix = []
			var buildings = []
			var elements = []
			
			var shapes = {
				background: {
					fillStyle: 'rgba(0, 0, 0, 1)'
				},
				border: {
					strokeStyle: 'rgba(255, 255, 255, 0.25)'
				},
				active: {
					fillStyle: 'rgba(0, 0, 0, 1)'
				},
				earth: {
					fillStyle: 'green',
					strokeStyle: 'rgba(0, 0, 0, 0)'
				},
				water: {
					fillStyle: 'blue',
					strokeStyle: 'rgba(0, 0, 0, 0)'
				},
				fire: {
					fillStyle: 'red',
					strokeStyle: 'rgba(0, 0, 0, 0)'
				},
				air: {
					fillStyle: 'white',
					strokeStyle: 'rgba(0, 0, 0, 0)'
				}
			}
			
			var overflow = 2
			var xCount = 20
			var yCount = 9
			var step = 1000
			var walk = true
			var time = (new Date).getTime()
			var added = false
			var recharge = 20000
			
			setInterval(function() {
				walk = true
				time = (new Date).getTime()
				added = false
			}, step)
			
			// create the matrix
			for (var i = 0; i < yCount; i++) {
				matrix.push([])
				
				for (var j = 0; j < xCount; j++) {
					matrix[i].push(0)
				}
			}
			
			// make a grid from the matrix
			var grid = new PF.Grid(matrix)
			
			/*
			// make some blocks unwalkable if needed
			for (var i = 0; i < horizontal; i++) {
				for (var j = 0; j < vertical; j++) {
					if (matrix[j][i] == 0) grid.setWalkableAt(j, i, false)
				}
			}
			*/
			
			var finder = new PF.AStarFinder({
			    allowDiagonal: true,
    			dontCrossCorners: true
			})
			
			var horizontal = matrix[0].length - overflow
			var vertical = matrix.length + 1
			var iw = window.innerWidth
			var ih = window.innerHeight
			var w = iw > ih ? iw : ih
			var h = ih < iw ? ih : iw
			var blockWidth = w / horizontal
			var blockHeight = h / vertical
			
			w = w + blockWidth * overflow
			h = h + blockHeight
			
			var canvas = {
				background: createHiDPICanvas(w, h, 1),
				buildings: createHiDPICanvas(w, h, 2),
				elements: createHiDPICanvas(w, h, 3),
				menu: createHiDPICanvas(w, h, 4)
			}
				
			// create a visual UI grid
			for (var i = 0; i < horizontal + 1; i++) { 
				line(canvas.background, shapes.border, blockWidth * i, 0, blockWidth * i, h)
			}
			
			for (var i = 1; i < vertical; i++) {
				line(canvas.background, shapes.border, 0, blockHeight * i, w, blockHeight * i)
			}
			
			for (var i = 0; i < horizontal + 4; i++) {
				for (var j = 0; j < vertical; j++) {
					//rect(canvas.background, shapes.background, blockWidth * i, blockHeight * j, blockWidth, blockHeight)
				}
			}
			
			/*
			//build unwalkable blocks if needed
			for (var i = 0; i < horizontal; i++) {
				for (var j = 0; j < vertical; j++) {
					if (matrix[j][i] == 1) rect(canvas.background, shapes.border, w / horizontal * i, h / vertical * j, w / horizontal, h / vertical)
					else if (matrix[j][i] > 1) {
						rect(canvas.background, shapes.element, w / horizontal * i, h / vertical * j, w / horizontal, h / vertical)
					}
				}
			}
			*/
			
			var creatingElement = false
			function createElement(event) {
				canvas.menu.clearRect(0, 0, w, h)
				
				var x = event.clientX
				var y = event.clientY
				var xBlock = Math.floor(x / blockWidth)
				var yBlock = Math.floor(y / blockHeight) - 1
				
				if (xBlock < horizontal / 2) {
					if (!creatingElement) {
						creatingElement = [xBlock, yBlock]
						
						for (var i = 0; i < types.length; i++) {
							rect(canvas.menu, shapes.active, (xBlock + i + 1) * blockWidth, yBlock * blockHeight, blockWidth, blockHeight)
							
							circle(canvas.menu, shapes[types[i]], (xBlock + i + 1) * blockWidth, yBlock * blockHeight, blockWidth, blockHeight)
						}
					}
					else if (
						creatingElement[0] == xBlock ||
						creatingElement[0] + 1 == xBlock ||
						creatingElement[0] + 2 == xBlock ||
						creatingElement[0] + 3 == xBlock &&
						creatingElement[1] == yBlock
					) {
						var type = xBlock - creatingElement[0]
						var id = elements.length
						var start = [creatingElement[0], creatingElement[1]]
						var end = [horizontal, start[1]]
						
						// create a building
						grid.setWalkableAt(start[0], start[1], false)
						circle(canvas.buildings, shapes[types[type]], (start[0] + 1) * blockWidth, start[1] * blockHeight, blockWidth, blockHeight)
			
						var element = {
							id: id,
							type: types[type],
							start: start,
							end: end,
							shapes: shapes[types[type]],
							path: finder.findPath(start[0], start[1], end[0], end[1], grid.clone()),
							recharge: (function () {
								setInterval(function() {
									var p = getElementIndex(id)
									elements[p].path = finder.findPath(start[0], start[1], end[0], end[1], grid.clone())
								}, recharge)
							})()
						}
						
						elements.push(element)
						creatingElement = false
					}
					else {
						creatingElement = false
					}
				}
				
				else {
					if (!creatingElement) {
						creatingElement = [xBlock, yBlock]
						
						for (var i = 0; i < types.length; i++) {
							rect(canvas.menu, shapes.active, (xBlock + i - types.length + 2) * blockWidth, yBlock * blockHeight, blockWidth, blockHeight)
							
							circle(canvas.menu, shapes[types[i]], (xBlock + i - types.length + 2) * blockWidth, yBlock * blockHeight, blockWidth, blockHeight)
						}
					}
					else if (
						creatingElement[0] - 3 == xBlock ||
						creatingElement[0] - 2 == xBlock ||
						creatingElement[0] - 1 == xBlock ||
						creatingElement[0] == xBlock &&
						creatingElement[1] == yBlock
					) {	
						var type = xBlock - creatingElement[0] + types.length - 1
						var id = elements.length
						var start = [creatingElement[0], creatingElement[1]]
						var end = [0, start[1]]
						
						// create a building
						grid.setWalkableAt(start[0], start[1], false)
						circle(canvas.buildings, shapes[types[type]], (start[0] + 1) *  blockWidth, start[1] * blockHeight, blockWidth, blockHeight)
						
						var element = {
							id: id,
							type: types[type],
							start: start,
							end: end,
							shapes: shapes[types[type]],
							// subtract one because of overflow
							path: finder.findPath(start[0], start[1], end[0], end[1], grid.clone()),
							recharge: (function () {
								setInterval(function() {
									var p = getElementIndex(id)
									elements[p].path = finder.findPath(start[0], start[1], end[0], end[1], grid.clone())
								}, recharge)
							})()
						}
						
						elements.push(element)
						creatingElement = false
					}
					else {
						creatingElement = false
					}
				}
			}
			
			/*
			// create static paths for the elements before starting
			for (var p = 0; p < elements.length; p++) {
				var element = elements[p]
				var path = finder.findPath(element.start[0], element.start[1], element.end[0], element.end[1], grid.clone())
				elements[p].path = path
			}
			*/
			
			function animate() {
				requestAnimationFrame(animate)
				
				canvas.elements.clearRect(0, 0, w, h)
				
				if (walk) {
					walk = false
					
					for (var p = 0; p < elements.length; p++) {
						if (elements[p].path.length) {
							
							for (var r = 0; r < elements.length; r++) {
								if (r == p) continue //don't update the same object
								
								//console.log(elements[p].path[1][0], elements[r].path[1][0])

								if (
									elements[p].path &&
									elements[p].path[1] &&
									elements[p].path[1].length &&
									elements[p].path[1][0] &&
									elements[p].path[1][1] &&
									elements[r].path &&
									elements[r].path[1] &&
									elements[r].path[1].length &&
									elements[r].path[1][0] &&
									elements[r].path[1][1] &&
										(
											elements[p].path[0][0] == elements[r].path[0][0] ||
											elements[p].path[0][0] == elements[r].path[1][0] ||
											elements[p].path[1][0] == elements[r].path[0][0] ||
											elements[p].path[1][0] == elements[r].path[1][0]
										) 
									&&
										(
											elements[p].path[0][1] == elements[r].path[0][1] ||
											elements[p].path[0][1] == elements[r].path[1][1] ||
											elements[p].path[1][1] == elements[r].path[0][1] ||
											elements[p].path[1][1] == elements[r].path[1][1]
										)									
								) {
									if (!fight(elements[p].type, elements[r].type)) {
										elements[p].path = []
										continue
									}
									if (!fight(elements[r].type, elements[p].type)) {
										elements[r].path = []
										continue
									}
								}
							}
						}
					}
					
					for (var p = 0; p < elements.length; p++) {
						var element = elements[p]
						
						if (
							element.path &&
							element.path[1] &&
							element.path[1].length
						) {
							elements[p].path = finder.findPath(elements[p].path[1][0], elements[p].path[1][1], elements[p].end[0], elements[p].end[1], grid.clone())
						}
					}
				}
				
				
				// move the elements according to their positions in space and time
				for (var p = 0; p < elements.length; p++) {
					var element = elements[p]
					
					if (
						element.path[1] &&
						element.path[1].length
					) {
						var x1 = element.path[0][0] * blockWidth
						var y1 = element.path[0][1] * blockHeight
						var x2 = element.path[1][0] * blockWidth
						var y2 = element.path[1][1] * blockHeight
						
						var dt = ((new Date).getTime() - time)
						var dx = x1 - (x1 - x2) * dt / step
						var dy = y1 - (y1 - y2) * dt / step
						
						circle(canvas.elements, element.shapes, dx, dy, blockWidth, blockHeight)	
					}
						
				}
			}
			requestAnimationFrame(animate)
			
			function fight(a, b) {
				switch(a) {
				    case 'rock':
						if (b == 'paper') return false
				        break
				    case 'paper':
						if (b == 'scissors') return false
						break
				    case 'scissors':
						if (b == 'rock') return false
	
				}
				return true
			}
			
			function line(ctx, shape, x1, y1, x2, y2) {
				ctx.beginPath()
				ctx.moveTo(x1, y1)
				ctx.lineTo(x2, y2)
				ctx.lineWidth = 1;
				ctx.strokeStyle = shape.strokeStyle
				ctx.stroke()
			}
			
			function rect(ctx, shape, x1, y1, x2, y2) {
				ctx.beginPath()
				ctx.rect(x1, y1, x2, y2)
				ctx.fillStyle = shape.fillStyle
				ctx.fill()	
			}
			
			function circle(ctx, shape, x1, y1, x2, y2) {
				ctx.beginPath()
				ctx.arc(x1 + (x2 / 2), y1 + (y2 / 2), Math.sqrt(x2 + y2), 0, 2 * Math.PI, false)
				ctx.fillStyle = shape.fillStyle
				ctx.fill()	
			}
			
			function createHiDPICanvas (w, h, z) {
			    ratio = PIXEL_RATIO
			    var can = document.createElement('canvas')
			    can.width = w * ratio
			    can.height = h * ratio
			    can.style.width = w + 'px'
			    can.style.height = h + 'px'
			    can.getContext('2d').setTransform(ratio, 0, 0, ratio, 0, 0)
				can.style.position = 'absolute'
				can.style.zIndex = z
				document.getElementsByClassName('game')[0].appendChild(can)
				return can.getContext('2d')
			}
			
			function getElementIndex(id) {
				for (var p = 0; p < elements.length; p++) {
					if (elements[p].id == id) return p
				}
			}
		</script>
	</body>
</html>
